"""
@file unicode.grapheme
@ref https://www.unicode.org/Public/UCD/latest/ucd
"""

import os
from dataclasses import dataclass
from datetime import date

import requests


@dataclass
class GraphemeType:
    GCB_UNDEFINED = 0
    # GraphemeBreakProperty.txt
    GCB_PREPEND = 1
    GCB_CR = 2
    GCB_LF = 3
    GCB_CONTROL = 4
    GCB_EXTEND = 5
    GCB_SPACING_MARK = 6
    GCB_L = 7
    GCB_V = 8
    GCB_T = 9
    GCB_LV = 10
    GCB_LVT = 11
    GCB_ZJW = 12
    # emoji-data.txt
    GCB_EMOJI = 13
    GCB_EMOJI_PRESENTATION = 14
    GCB_EMOJI_MODIFIER_BASE = 15
    GCB_EMOJI_COMPONENT = 16
    GCB_EXTENDED_PICTOGRAPHIC = 17
    # PropList.txt
    GCB_DIACRITIC = 18


GraphemeMap = {
    "Undefined": GraphemeType.GCB_UNDEFINED,
    # GraphemeBreakProperty.txt
    "Prepend": GraphemeType.GCB_PREPEND,
    "CR": GraphemeType.GCB_CR,
    "LF": GraphemeType.GCB_LF,
    "Control": GraphemeType.GCB_CONTROL,
    "Extend": GraphemeType.GCB_EXTEND,
    "SpacingMark": GraphemeType.GCB_SPACING_MARK,
    "L": GraphemeType.GCB_L,
    "V": GraphemeType.GCB_V,
    "T": GraphemeType.GCB_T,
    "LV": GraphemeType.GCB_LV,
    "LVT": GraphemeType.GCB_LVT,
    "ZWJ": GraphemeType.GCB_ZJW,
    # emoji-data.txt
    "Emoji": GraphemeType.GCB_EMOJI,
    "Emoji_Presentation": GraphemeType.GCB_EMOJI_PRESENTATION,
    "Emoji_Modifier_Base": GraphemeType.GCB_EMOJI_MODIFIER_BASE,
    "Emoji_Component": GraphemeType.GCB_EMOJI_COMPONENT,
    "Extended_Pictographic": GraphemeType.GCB_EXTENDED_PICTOGRAPHIC,
    # PropList.txt
    "Diacritic": GraphemeType.GCB_DIACRITIC,
}

# filter unicode data by category type
GRAPHEMES = [
    "Undefined",  # undefined
    # GraphemeBreakProperty.txt
    "CR",
    "LF",
    "Control",
    "Extend",
    "Prepend",
    "SpacingMark",
    "L",
    "V",
    "T",
    "LV",
    "LVT",
    "ZWJ",
    # emoji-data.txt
    "Emoji",  # includes regionals
    "Emoji_Presentation",  # includes regionals
    "Emoji_Modifier_Base",
    "Emoji_Component",  # includes regionals
    "Extended_Pictographic",
    # PropList.txt
    "Diacritic",
]


def unicode_data_fetch(url: str, path: str) -> list[str]:
    # Read from local cache
    if os.path.isfile(path):
        with open(path, "r") as file:
            return file.read().splitlines()
    # Write to local cache
    lines = requests.get(url).text.splitlines()
    with open(path, "w") as file:
        for line in lines:
            file.write(line + "\n")
    return lines


def unicode_data_cache() -> list[str]:
    base_dir = "data"
    base_url = "https://www.unicode.org/Public/UCD/latest/ucd"
    os.makedirs(base_dir, exist_ok=True)
    files = {
        "grapheme": (
            f"{base_url}/auxiliary/GraphemeBreakProperty.txt",
            f"{base_dir}/GraphemeBreakProperty.txt",
        ),
        "emoji": (
            f"{base_url}/emoji/emoji-data.txt",
            f"{base_dir}/emoji-data.txt",
        ),
        "prop": (
            f"{base_url}/PropList.txt",
            f"{base_dir}/PropList.txt",
        ),
    }
    lines = []
    for _, (url, path) in files.items():
        lines.extend(unicode_data_fetch(url, path))
    return lines


# C struct is defined as struct { uint32_t lo, hi; }
# lo for the start of the range if it is a tuple or range
# hi for the end of the range if it is a tuple or range
# both lo and hi are equal if it is a singleton
def unicode_data_parse(lines: list[str]) -> list[tuple[int, int, int]]:
    ranges = []
    for line in lines:
        if not line or line[0] == "#" or ";" not in line:
            continue

        lvalue, rvalue = list(value.strip() for value in line.split(";"))

        grapheme = rvalue.split("#")[0].strip()
        if grapheme not in GRAPHEMES:
            continue

        # handle single or range
        if ".." in lvalue:  # range
            lo, hi = list(int(x, 16) for x in lvalue.split(".."))
        elif " " in lvalue:  # tuple
            lo, hi = list(int(x, 16) for x in lvalue.split(" "))
        else:  # singleton
            lo = hi = int(lvalue.strip(), 16)
        ranges.append((lo, hi, GraphemeMap[grapheme]))
    return ranges


def unicode_data_enum_map() -> dict[int, str]:
    # Map grapheme enums to names
    return {v: f"GCB_{k.upper()}" for k, v in GraphemeMap.items()}


def unicode_data_comments() -> list[str]:
    version = 1
    lines = []
    lines.append("/**")
    lines.append(" * @warning This file is auto-generated. Do not edit directly.")
    lines.append(" * @brief Grapheme cluster break property data.")
    lines.append(" * @ref Unicode UCD - Generated by unicode.generate.py")
    lines.append(f" * @version {version}")
    lines.append(f" * @date {date.today()}")
    lines.append(" */\n")
    return lines


def unicode_data_include(ranges: list[tuple[int, int, int]]) -> str:
    enum_map = unicode_data_enum_map()

    lines = unicode_data_comments()

    lines.append("#ifndef UTF8_GRAPHEME_DATA_H")
    lines.append("#define UTF8_GRAPHEME_DATA_H\n")

    lines.append("#include <stddef.h>")
    lines.append("#include <stdint.h>\n")

    lines.append("typedef enum GraphemeClass {")
    for v in GraphemeMap.values():
        lines.append(f"    {enum_map[v]} = {v},")
    lines.append("} GraphemeClass;\n")

    lines.append("typedef struct Grapheme {")
    lines.append("    uint32_t lo, hi;")
    lines.append("    GraphemeClass cls;")
    lines.append("} Grapheme;\n")

    lines.append("extern const Grapheme graphemes[];")
    lines.append("extern const size_t GRAPHEME_SIZE;\n")

    lines.append("#endif // UTF8_GRAPHEME_DATA_H\n")

    return "\n".join(lines)


def unicode_data_source(ranges: list[tuple[int, int, int]]) -> str:
    enum_map = unicode_data_enum_map()

    lines = unicode_data_comments()

    lines.append('#include "utf8/grapheme-data.h"\n')

    lines.append("const Grapheme graphemes[] = {")
    for lo, hi, t in ranges:
        lines.append(
            f"    {{0x{lo:06X}, 0x{hi:06X}, {enum_map[t]}}}, // {GRAPHEMES[t]}"
        )
    lines.append("};\n")

    lines.append("const size_t GRAPHEME_SIZE = sizeof(graphemes) / sizeof(Grapheme);\n")

    return "\n".join(lines)


def main():
    cache = unicode_data_cache()
    data = unicode_data_parse(cache)

    header = unicode_data_include(data)
    with open("include/utf8/grapheme-data.h", "w") as file:
        file.write(header)

    source = unicode_data_source(data)
    with open("src/utf8/grapheme-data.c", "w") as file:
        file.write(source)


if __name__ == "__main__":
    main()
